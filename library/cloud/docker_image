#!/usr/bin/env python
#

# (c) 2014, Pavel Antonov <antonov@adwz.ru>
#
# This file is part of Ansible
#
# This module is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this software.  If not, see <http://www.gnu.org/licenses/>.

######################################################################

DOCUMENTATION = '''
---
module: docker_image
author: Pavel Antonov
version_added: "1.5"
short_description: manage docker images
description:
     - Create, check and remove docker images
options:
  path:
    description:
       - Path to directory with Dockerfile, if building from source. (Omit if pulling from repository.)
    required: false
    default: null
    aliases: []
  name:
    description:
       - Name to apply to the resulting image if building from source, or repository to pull from otherwise
    required: true
    default: null
    aliases: []
  tag:
    description:
       - Image tag to pull from repository or apply when building
    required: false
    default: ""
    aliases: []
  nocache:
    description:
      - Do not use cache (when building)
    required: false
    default: false
    aliases: []
  docker_url:
    description:
      - URL of docker host to issue commands to
    required: false
    default: unix://var/run/docker.sock
    aliases: []
  state:
    description:
      - Set the state of the image ("force"/"build" will attempt to pull or build the image even if it already exists on the host)
    required: false
    default: present
    choices: [ "present", "absent", "build", "force" ]
    aliases: []
  timeout:
    description:
      - Set image operation timeout
    required: false
    default: 600
    aliases: []
  source:
    description:
      - The source of the image that should exist
    required: false
    default: "local"
    choices: [ "local", "repository" ]
    aliases: []
    version_added: "1.6"
  username:
    description:
      - Registry username (if pulling from a private registry)
    required: false
    default: null
    aliases: []
    version_added: "1.6"
  password:
    description:
      - Registry password (if pulling from a private registry)
    required: false
    default: null
    aliases: []
    version_added: "1.6"
requirements: [ "docker-py" ]
'''

EXAMPLES = '''
Build docker image if required. Path should contains Dockerfile to build image:

- hosts: web
  sudo: yes
  tasks:
  - name: check or build image
    docker_image: path="/path/to/build/dir" name="my/app" state=present

Build new version of image:

- hosts: web
  sudo: yes
  tasks:
  - name: check or build image
    docker_image: path="/path/to/build/dir" name="my/app" state=force

Remove image from local docker storage:

- hosts: web
  sudo: yes
  tasks:
  - name: run tomcat servers
    docker_image: name="my/app" state=absent

Ensure the coreos/etcd has been pulled from the public Docker registry

- hosts: web
  sudo: yes
  tasks
  - name: Ensure coreos/etcd image exists
    docker_image: source=repository name=coreos/etcd

'''

try:
    import sys
    import re
    import json
    import docker.client
    from requests.exceptions import *
    from urlparse import urlparse
except ImportError, e:
    print "failed=True msg='failed to import python module: %s'" % e
    sys.exit(1)

class DockerImageManager:

    def __init__(self, module):
        self.module = module
        self.path = self.module.params.get('path')
        self.name = self.module.params.get('name')
        self.tag = self.module.params.get('tag')
        self.nocache = self.module.params.get('nocache')
        docker_url = urlparse(module.params.get('docker_url'))
        self.client = docker.Client(base_url=docker_url.geturl(), timeout=module.params.get('timeout'))
        self.changed = False
        self.log = []
        self.error_msg = None

    def get_log(self, as_string=True):
        return "".join(self.log) if as_string else self.log

    def build(self):
        stream = self.client.build(self.path, tag=':'.join([self.name, self.tag]), nocache=self.nocache, rm=True, stream=True)
        success_search = r'Successfully built ([0-9a-f]+)'
        image_id = None
        self.changed = True

        for chunk in stream:
            chunk_json = json.loads(chunk)

            if 'error' in chunk_json:
                self.error_msg = chunk_json['error']
                return None

            if 'stream' in chunk_json:
                output = chunk_json['stream']
                self.log.append(output)
                match = re.search(success_search, output)
                if match:
                    image_id = match.group(1)

        return image_id

    def pull(self):
        """Pull an image from index.docker.io or a hosted private registry"""
        image = self.module.params.get('name')
        tag = self.module.params.get('tag')
        username = self.module.params.get('username')
        namespace = image.split('/')[0]

        if username:
            self.client.login(username, password=self.module.params.get('password'), registry=namespace)

        stream = self.client.pull(image, tag=tag, stream=True)
        self.changed = True

        last_status = None
        last_id = None
        for chunk in stream:
            chunk_json = json.loads(chunk)
            if 'error' in chunk_json:
                self.error_msg = chunk_json['error']
                return None
            else:
                # The stream from client.pull() is SUPER noisy.
                #
                # Rather than returning hundreds of lines where, for many, the
                # only change from the previous line is a slight difference in
                # an ASCII progress bar, we just keep a log of each line where
                # either the id or status changed from the previous line. This
                # should give the user a good idea of what's going on without
                # overwhelming them with unnecessary information.
                id = chunk_json['id']
                status = chunk_json['status']
                if status != last_status or id != last_id:
                    self.log.append('[{}] {}... '.format(id, status))
                    last_id = id
                    last_status = status

        return last_id


    def has_changed(self):
        return self.changed

    def get_images(self):
        filtered_images = []
        images = self.client.images()
        for i in images:
            # Docker-py version >= 0.3 (Docker API >= 1.8)
            if 'RepoTags' in i:
                repotag = '%s:%s' % (getattr(self, 'name', ''), getattr(self, 'tag', 'latest'))
                if not self.name or repotag in i['RepoTags']:
                    filtered_images.append(i)
            # Docker-py version < 0.3 (Docker API < 1.8)
            elif (not self.name or self.name == i['Repository']) and (not self.tag or self.tag == i['Tag']):
                filtered_images.append(i)
        return filtered_images

    def remove_images(self):
        images = self.get_images()
        for i in images:
            try:
                self.client.remove_image(i['Id'])
                self.changed = True
            except docker.APIError as e:
                # image can be removed by docker if not used
                pass


def main():
    module = AnsibleModule(
        argument_spec = dict(
            path            = dict(required=False, default=None),
            name            = dict(required=True),
            tag             = dict(required=False, default=""),
            nocache         = dict(default=False, type='bool'),
            state           = dict(default='present', choices=['absent', 'present', 'build', 'force']),
            docker_url      = dict(default='unix://var/run/docker.sock'),
            timeout         = dict(default=600, type='int'),
            source          = dict(default='local', choices=['local', 'repository']),
            username        = dict(required=False, default=None),
            password        = dict(required=False, default=None),
        ),
        mutually_exclusive = [
            ['path', 'username'],
            ['path', 'password'],
            ['nocache', 'username'],
            ['nocache', 'password']
        ]
    )
    ACTION_BUILD = 1
    ACTION_PULL = 2

    try:
        manager = DockerImageManager(module)
        state = module.params.get('state')
        source = module.params.get('source')

        # build image if not exists
        if state == "present":
            images = manager.get_images()
            if len(images) == 0 or state in ['force', 'build']:
                if source == 'local':
                    action = ACTION_BUILD
                else:
                    action = ACTION_PULL
        # remove image or images
        elif state == "absent":
            manager.remove_images()

        if action:
            image_id = None
            verb = None
            if action == ACTION_BUILD:
                image_id = manager.build()
                verb = 'built'
            elif action == ACTION_PULL:
                image_id = manager.pull()
                verb = 'pulled'
            if image_id:
                result = dict(
                    failed      = False,
                    changed     = manager.has_changed(),
                    image_id    = image_id,
                    msg         = "Image %s %s" % (image_id, verb),
                )
            else:
                result = dict(
                    failed      = True,
                    changed     = manager.has_changed(),
                    msg = "Error: %s" % manager.error_msg,
                    log = manager.get_log(),
                )

        module.exit_json(**result)

    except docker.client.APIError as e:
        module.exit_json(failed=True, changed=manager.has_changed(), msg="Docker API error: " + e.explanation)

    except RequestException as e:
        module.exit_json(failed=True, changed=manager.has_changed(), msg=repr(e))

# import module snippets
from ansible.module_utils.basic import *

main()
