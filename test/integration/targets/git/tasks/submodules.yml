#
# Submodule tests
#

# Repository A with submodules defined  (repo_submodules)
#   .gitmodules file points to Repository I
# Repository B forked from A that has newer commits (repo_submodules_newer)
#   .gitmodules file points to Repository II instead of I
#   .gitmodules file also points to Repository III
# Repository I for submodule1 (repo_submodule1)
#   Has 1 file checked in
# Repository II forked from I that has newer commits (repo_submodule1_newer)
#   Has 2 files checked in
# Repository III for a second submodule (repo_submodule2)
#   Has 1 file checked in

- name: SUBMODULES | setup
  block:
    - name: SUBMODULES | setup | start git daemon and create repositories
      include_role: name=test_utils/roles/git-repos
      vars:
        repositories:
          - test_submodules_newer.git
          - test_submodules_subm1.git
          - test_submodules_subm2.git
        exec:
          - 'echo initial > README.md'
          - 'git add README.md && git commit -m "Initial commit"'
          - 'git tag v0.1'
          - 'git push origin {{ git_default_branch }} --tags'

    - name: SUBMODULES | setup | add submodule1
      include_role: name=test_utils/roles/git-repos
      vars:
        repositories:
          - test_submodules_newer.git
        exec:
          - 'git submodule add --name submodule1 git://localhost/test_submodules_subm1.git submodule1'
          # workaround for changing default submodule branch name
          # ubuntu2004 docker image uses
          # https://git-scm.com/docs/git-submodule/2.25.0#Documentation/git-submodule.txt-set-branch-d--default--ltpathgt
          # which changes to HEAD in 2.28.0+
          # https://git-scm.com/docs/git-submodule/2.28.0#Documentation/git-submodule.txt-set-branch-d--default--ltpathgt
          - 'git submodule set-branch --branch {{ git_default_branch }} submodule1'
          - 'git submodule sync && git submodule update --init'
          - 'git add . && git commit -m "Add submodule1"'
          - 'git tag v0.2'
          - 'git push origin {{ git_default_branch }} --tags'

    - name: SUBMODULES | setup | fork submodule1
      shell: 'cp -pr test_submodules_subm1.git test_submodules_subm1_newer.git'
      args:
        chdir: '{{ remote_tmp_dir }}/git_repositories'

    - name: SUBMODULES | setup | update forked submodule1
      include_role: name=test_utils/roles/git-repos
      vars:
        repositories:
          - test_submodules_subm1_newer.git
        exec:
          - 'echo update > newer_commit'
          - 'git add newer_commit && git commit -m "Add an update"'
          - 'git tag v0.3'
          - 'git push origin {{ git_default_branch }} --tags'

    - name: SUBMODULES | setup | add submodule2 and update the url for submodule1
      include_role: name=test_utils/roles/git-repos
      vars:
        repositories:
          - test_submodules_newer.git
        exec:
          - 'git submodule add --name submodule2 git://localhost/test_submodules_subm2.git submodule2'
          - 'git config -f .gitmodules submodule.submodule1.url git://localhost/test_submodules_subm1_newer.git'
          # same workaround as above
          - 'git submodule set-branch --branch {{ git_default_branch }} submodule2'
          - 'rm -rf submodule1'
          - 'rm -rf .git/modules/submodule1'
          - 'git submodule sync && git submodule update --init'
          - 'cd submodule1; git checkout tags/v0.3'
          - 'git add . && git commit -m "Add submodule2 and update submodule1"'
          - 'git tag v0.3'
          - 'git push origin {{ git_default_branch }} --tags'

- name: Determine commits for each tag
  command: "git rev-list -n 1 {{ tag }}"
  args:
    chdir: "{{ remote_tmp_dir }}/git_repositories/test_submodules_newer.git"
  loop_control:
    loop_var: tag
  loop:
    - v0.1
    - v0.2
    - v0.3
  register: main_repo_commit

- set_fact:
    commit_0: "{{ main_repo_commit.results[0].stdout }}"
    commit_1: "{{ main_repo_commit.results[1].stdout }}"
    commit_2: "{{ main_repo_commit.results[2].stdout }}"

- name: SUBMODULES | clear checkout_dir
  file:
    state: absent
    path: "{{ checkout_dir }}"

- name: SUBMODULES | Test that clone without recursive does not retrieve submodules
  git:
    repo: "{{ repo_submodules }}"
    version: "{{ commit_1 }}"
    dest: "{{ checkout_dir }}"
    recursive: no

- name: SUBMODULES | List submodule1
  command: 'ls -1a {{ checkout_dir }}/submodule1'
  register: submodule1

- name: SUBMODULES | Ensure submodule1 is at the appropriate commit
  assert:
    that: '{{ submodule1.stdout_lines | length }} == 2'

- name: SUBMODULES | clear checkout_dir
  file:
    state: absent
    path: "{{ checkout_dir }}"


- name: SUBMODULES | Test that clone with recursive retrieves submodules
  git:
    repo: "{{ repo_submodules }}"
    dest: "{{ checkout_dir }}"
    version: "{{ commit_1 }}"
    recursive: yes

- name: SUBMODULES | List submodule1
  command: 'ls -1a {{ checkout_dir }}/submodule1'
  register: submodule1

- name: SUBMODULES | Ensure submodule1 is at the appropriate commit
  assert:
    that: '{{ submodule1.stdout_lines | length }} == 4'

- name: SUBMODULES | Copy the checkout so we can run several different tests on it
  command: 'cp -pr {{ checkout_dir }} {{ checkout_dir }}.bak'


- name: SUBMODULES | Test that update without recursive does not change submodules
  git:
    repo: "{{ repo_submodules }}"
    version: "{{ commit_2 }}"
    dest: "{{ checkout_dir }}"
    recursive: no
    update: yes
    track_submodules: yes

- name: SUBMODULES | List submodule1
  command: 'ls -1a {{ checkout_dir }}/submodule1'
  register: submodule1

- name: SUBMODULES | Stat submodule2
  stat:
    path: "{{ checkout_dir }}/submodule2"
  register: submodule2

- name: SUBMODULES | List submodule2
  command: ls -1a {{ checkout_dir }}/submodule2
  register: submodule2

- name: SUBMODULES | Ensure both submodules are at the appropriate commit
  assert:
    that:
      - '{{ submodule1.stdout_lines|length }} == 4'
      - '{{ submodule2.stdout_lines|length }} == 2'


- name: SUBMODULES | Remove checkout dir
  file:
    state: absent
    path: "{{ checkout_dir }}"

- name: SUBMODULES | Restore checkout to prior state
  command: 'cp -pr {{ checkout_dir }}.bak {{ checkout_dir }}'


- name: SUBMODULES | Test that update with recursive updated existing submodules
  git:
    repo: "{{ repo_submodules }}"
    version: "{{ commit_2 }}"
    dest: "{{ checkout_dir }}"
    update: yes
    recursive: yes
    track_submodules: yes

- name: SUBMODULES | List submodule 1
  command: 'ls -1a {{ checkout_dir }}/submodule1'
  register: submodule1

- name: SUBMODULES | Ensure submodule1 is at the appropriate commit
  assert:
    that: '{{ submodule1.stdout_lines | length }} == 5'


- name: SUBMODULES | Test that update with recursive found new submodules
  command: 'ls -1a {{ checkout_dir }}/submodule2'
  register: submodule2

- name: SUBMODULES | Enusre submodule2 is at the appropriate commit
  assert:
    that: '{{ submodule2.stdout_lines | length }} == 4'

- name: SUBMODULES | clear checkout_dir
  file:
    state: absent
    path: "{{ checkout_dir }}"


- name: SUBMODULES | Clone main submodule repository
  git:
    repo: "{{ repo_submodules }}"
    dest: "{{ checkout_dir }}/test.gitdir"
    version: "{{ commit_1 }}"
    recursive: yes

- name: SUBMODULES | Test that cloning submodule with .git in directory name works
  git:
    repo: "{{ repo_submodule1 }}"
    dest: "{{ checkout_dir }}/test.gitdir/submodule1"

- name: SUBMODULES | List submodule1
  command: 'ls -1a {{ checkout_dir }}/test.gitdir/submodule1'
  register: submodule1

- name: SUBMODULES | Ensure submodule1 is at the appropriate commit
  assert:
    that: '{{ submodule1.stdout_lines | length }} == 4'
